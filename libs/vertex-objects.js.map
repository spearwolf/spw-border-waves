{"version":3,"file":"vertex-objects.js.map","sources":["../src/constants.ts","../src/findNextPowerOf2.ts","../../../node_modules/tslib/tslib.es6.js","../src/TextureAtlas.ts","../src/TextureCoords.ts","../src/TileSet.ts","../src/FrameBasedAnimations.ts","../src/getDescriptorOf.ts","../src/createTypedArray.ts","../src/createVertexObjectPrototype.ts","../src/VertexObjectBuffer.ts","../src/VertexAttributeDescriptor.ts","../src/VertexObjectDescriptor.ts","../src/VertexObjectPool.ts","../src/toDrawUsage.ts","../src/initializeAttributes.ts","../src/createIndicesArray.ts","../src/selectAttributes.ts","../src/selectBuffers.ts","../src/InstancedVertexObjectGeometry.ts","../src/initializeInstancedAttributes.ts","../src/isPowerOf2.ts","../src/PowerOf2ImageLoader.ts","../src/ShaderTool.ts","../src/TextureFactory.ts","../src/TextureImageLoader.ts","../src/TexturePackerJson.ts","../src/TextureAtlasLoader.ts","../src/TileSetLoader.ts","../src/unpick.ts","../src/VertexObjectGeometry.ts","../src/VertexObjects.ts"],"sourcesContent":["/**\n * @category Vertex Objects\n */\nexport const voBuffer = Symbol('voBuffer');\n\n/**\n * @category Vertex Objects\n */\nexport const voIndex = Symbol('voIndex');\n","export const findNextPowerOf2 = (x: number): number => {\n  let p = 1;\n  while (x > p) p <<= 1;\n  return p;\n};\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","import {TextureCoords} from './TextureCoords';\n\n/**\n * @category Texture Mapping\n */\nexport type TextureAtlasFrameData = Record<string, any>;\n\n/**\n * @category Texture Mapping\n */\nexport interface TextureAtlasFrame {\n  coords: TextureCoords;\n  data?: TextureAtlasFrameData;\n}\n\ntype TextureAtlasArgs = [coords: TextureCoords, data?: TextureAtlasFrameData];\n\ntype TextureAtlasFrameName = string | symbol;\n\ntype NamedTextureAtlasArgs = [name: TextureAtlasFrameName, coords: TextureCoords, data?: TextureAtlasFrameData];\n\nconst isNamedTextureAtlasArgs = (args: TextureAtlasArgs | NamedTextureAtlasArgs): args is NamedTextureAtlasArgs =>\n  typeof args[0] === 'string' || typeof args[0] === 'symbol';\n\nconst rand = (max: number) => (Math.random() * max) | 0;\n\n/**\n * @category Texture Mapping\n */\nexport class TextureAtlas {\n  #frames: TextureAtlasFrame[] = [];\n  #frameNames: Map<TextureAtlasFrameName, number> = new Map();\n\n  /**\n   * returns the frame id.\n   * the frame id starts at 0 and increases by 1 each time you add another frame.\n   */\n  add(...args: TextureAtlasArgs | NamedTextureAtlasArgs): number {\n    const id = this.#frames.length;\n    if (isNamedTextureAtlasArgs(args)) {\n      this.#frameNames.set(args[0], id);\n      this.#frames.push({coords: args[1], data: args[2]});\n    } else {\n      this.#frames.push({coords: args[0], data: args[1]});\n    }\n    return id;\n  }\n\n  get size(): number {\n    return this.#frames.length;\n  }\n\n  get(id: number): TextureAtlasFrame | undefined {\n    return this.#frames[id];\n  }\n\n  frameId(name: TextureAtlasFrameName): number | undefined {\n    return this.#frameNames.get(name);\n  }\n\n  frame(name: TextureAtlasFrameName): TextureAtlasFrame | undefined {\n    return this.#frames[this.#frameNames.get(name)];\n  }\n\n  /**\n   * frame names that are symbols are not found here,\n   * but if no argument is given, all names are returned (including symbols)\n   */\n  frameNames(match?: string | RegExp): TextureAtlasFrameName[] {\n    const frameNames = Array.from(this.#frameNames.keys());\n    if (match != null) {\n      const regex = typeof match === 'string' ? new RegExp(match) : match;\n      return frameNames.filter((name) => typeof name === 'string' && regex.test(name));\n    }\n    return frameNames;\n  }\n\n  randomFrameId(): number {\n    return rand(this.#frames.length);\n  }\n\n  randomFrame(): TextureAtlasFrame {\n    return this.#frames[this.randomFrameId()];\n  }\n\n  randomFrameName(): TextureAtlasFrameName {\n    const randomIdx = rand(this.#frameNames.size);\n    let idx = 0;\n    for (const name of this.#frameNames.keys()) {\n      if (idx === randomIdx) {\n        return name;\n      }\n      ++idx;\n    }\n    return undefined;\n  }\n\n  randomFrameIds(count: number): number[] {\n    const frameIds: number[] = [];\n    for (let i = 0; i < count; i++) {\n      frameIds.push(this.randomFrameId());\n    }\n    return frameIds;\n  }\n\n  randomFrames(count: number): TextureAtlasFrame[] {\n    const frames: TextureAtlasFrame[] = [];\n    for (let i = 0; i < count; i++) {\n      frames.push(this.randomFrame());\n    }\n    return frames;\n  }\n\n  randomFrameNames(count: number): TextureAtlasFrameName[] {\n    const names: TextureAtlasFrameName[] = [];\n    for (let i = 0; i < count; i++) {\n      names.push(this.randomFrameName());\n    }\n    return names;\n  }\n}\n","const minCoord = (current: TextureCoords, scalarKey: 'x' | 'y', sizeKey: 'width' | 'height') => {\n  let texCoords: TextureCoords = current;\n  let scalar = 0;\n\n  while (texCoords.parent != null) {\n    scalar += texCoords[scalarKey];\n    texCoords = texCoords.parent;\n  }\n\n  return scalar / texCoords[sizeKey];\n};\n\nconst maxCoord = (current: TextureCoords, scalarKey: 'x' | 'y', sizeKey: 'width' | 'height') => {\n  let texCoords: TextureCoords = current;\n  let coord = current[sizeKey];\n\n  while (texCoords.parent != null) {\n    coord += texCoords[scalarKey];\n    texCoords = texCoords.parent;\n  }\n\n  return coord / texCoords[sizeKey];\n};\n\n/**\n * @category Texture Mapping\n */\nexport class TextureCoords {\n  static readonly FLIP_HORIZONTAL = 1;\n  static readonly FLIP_VERTICAL = 2;\n  static readonly FLIP_DIAGONAL = 4;\n\n  x = 0;\n  y = 0;\n\n  width = 0;\n  height = 0;\n\n  flip = 0;\n\n  parent?: TextureCoords;\n\n  constructor(\n    ...args:\n      | undefined\n      | [parent: TextureCoords, x?: number, y?: number, width?: number, height?: number]\n      | [x?: number, y?: number, width?: number, height?: number]\n  ) {\n    if (args[0] instanceof TextureCoords) {\n      this.parent = args[0];\n      this.x = args[1] ?? 0;\n      this.y = args[2] ?? 0;\n      this.width = args[3] ?? 0;\n      this.height = args[4] ?? 0;\n    } else if (args?.length) {\n      this.x = args[0] ?? 0;\n      this.y = args[1] ?? 0;\n      this.width = args[2] ?? 0;\n      this.height = args[3] ?? 0;\n    }\n  }\n\n  clone(): TextureCoords {\n    const texCoords = new TextureCoords();\n    texCoords.parent = this.parent;\n    texCoords.x = this.x;\n    texCoords.y = this.y;\n    texCoords.width = this.width;\n    texCoords.height = this.height;\n    texCoords.flip = this.flip;\n    return texCoords;\n  }\n\n  get root(): TextureCoords | undefined {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let root: TextureCoords = this;\n    while (root.parent) {\n      root = root.parent;\n    }\n    return root;\n  }\n\n  get flipH(): boolean {\n    return (this.flip & TextureCoords.FLIP_HORIZONTAL) > 0;\n  }\n\n  set flipH(flip: boolean) {\n    this.flip =\n      (flip ? TextureCoords.FLIP_HORIZONTAL : 0) | (this.flip & (TextureCoords.FLIP_VERTICAL | TextureCoords.FLIP_DIAGONAL));\n  }\n\n  get flipV(): boolean {\n    return (this.flip & TextureCoords.FLIP_VERTICAL) > 0;\n  }\n\n  set flipV(flip: boolean) {\n    this.flip =\n      (flip ? TextureCoords.FLIP_VERTICAL : 0) | (this.flip & (TextureCoords.FLIP_HORIZONTAL | TextureCoords.FLIP_DIAGONAL));\n  }\n\n  get flipD(): boolean {\n    return (this.flip & TextureCoords.FLIP_DIAGONAL) > 0;\n  }\n\n  set flipD(flip: boolean) {\n    this.flip =\n      (flip ? TextureCoords.FLIP_DIAGONAL : 0) | (this.flip & (TextureCoords.FLIP_VERTICAL | TextureCoords.FLIP_HORIZONTAL));\n  }\n\n  flipHorizontal(): TextureCoords {\n    this.flipH = !this.flipH;\n    return this;\n  }\n\n  flipVertical(): TextureCoords {\n    this.flipV = !this.flipV;\n    return this;\n  }\n\n  flipDiagonal(): TextureCoords {\n    this.flipD = !this.flipD;\n    return this;\n  }\n\n  get s(): number {\n    const {flipD} = this;\n    return this.flipH\n      ? maxCoord(this, flipD ? 'y' : 'x', flipD ? 'height' : 'width')\n      : minCoord(this, flipD ? 'y' : 'x', flipD ? 'height' : 'width');\n  }\n\n  get t(): number {\n    const {flipD} = this;\n    return this.flipV\n      ? maxCoord(this, flipD ? 'x' : 'y', flipD ? 'width' : 'height')\n      : minCoord(this, flipD ? 'x' : 'y', flipD ? 'width' : 'height');\n  }\n\n  get s1(): number {\n    const {flipD} = this;\n    return this.flipH\n      ? minCoord(this, flipD ? 'y' : 'x', flipD ? 'height' : 'width')\n      : maxCoord(this, flipD ? 'y' : 'x', flipD ? 'height' : 'width');\n  }\n\n  get t1(): number {\n    const {flipD} = this;\n    return this.flipV\n      ? minCoord(this, flipD ? 'x' : 'y', flipD ? 'width' : 'height')\n      : maxCoord(this, flipD ? 'x' : 'y', flipD ? 'width' : 'height');\n  }\n\n  get u(): number {\n    return this.s1 - this.s;\n  }\n\n  get v(): number {\n    return this.t1 - this.t;\n  }\n}\n","import {TextureAtlas, TextureAtlasFrame} from './TextureAtlas';\nimport {TextureCoords} from './TextureCoords';\n\n//\n// +---------------------------------------------+\n// |         margin                              |\n// |   +---------------+-----+---------------+   |\n// |   |    padding    |     |    padding    |   |\n// |   |  +---------+  |     |  +---------+  |   |\n// |   |  |.........|  |     |  |.........|  |   |\n// |   |  |.........|  |     |  |.........|  |   |\n// |   |  |.........|  |     |  |.........|  |   |\n// |   |  +---------+  |     |  +---------+  |   |\n// |   |               |     |               |   |\n// |   +---------------+     +---------------+   |\n// |   |               spacing               |   |\n// |   +---------------+     +---------------+   |\n// |   |    padding    |     |    padding    |   |\n// |   |  +---------+  |     |  +---------+  |   |\n// |   |  |.........|  |     |  |.........|  |   |\n// |   |  |.........|  |     |  |.........|  |   |\n// |   |  |.........|  |     |  |.........|  |   |\n// |   |  +---------+  |     |  +---------+  |   |\n// |   |               |     |               |   |\n// |   +---------------+-----+---------------+   |\n// |         margin                              |\n// +---------------------------------------------+\n//\n\nconst rand = (max: number) => (Math.random() * max) | 0;\n\n/**\n * @category Texture Mapping\n */\nexport interface TileSetOptions {\n  tileWidth?: number;\n  tileHeight?: number;\n\n  margin?: number;\n  spacing?: number;\n  padding?: number;\n\n  tileCount?: number;\n\n  firstId?: number;\n}\n\n/**\n * The [[TileSet]] maps _tileIds_ to _frameIds_.\n * Unlike the `frameId` of [[TextureAtlas]], the `tileId` starts at 1 by default (but is optionally configurable using the `firstId` option).\n * The `frameId` range of a [[TileSet]] starts at `firstFrameId` and goes without gaps to up to `firstFrameId + tileCount - 1`.\n *\n * @category Texture Mapping\n */\nexport class TileSet {\n  readonly atlas: TextureAtlas;\n  readonly baseCoords: TextureCoords;\n  readonly options: TileSetOptions;\n\n  tileCount = 0;\n\n  /**\n   * The `frameId` of the _first_ tile\n   */\n  firstFrameId = -1;\n\n  constructor(...args: [TextureAtlas, TextureCoords, TileSetOptions?] | [TextureCoords, TileSetOptions?]) {\n    if (args[0] instanceof TextureAtlas) {\n      const [atlas, baseCoords, options] = args as [TextureAtlas, TextureCoords, TileSetOptions];\n      this.atlas = atlas;\n      this.baseCoords = baseCoords;\n      this.options = options;\n    } else {\n      this.atlas = new TextureAtlas();\n      const [baseCoords, options] = args as [TextureCoords, TileSetOptions];\n      this.baseCoords = baseCoords;\n      this.options = options;\n    }\n    this.#createTextureCoords();\n  }\n\n  get tileWidth(): number {\n    return this.options?.tileWidth ?? this.baseCoords.width;\n  }\n\n  get tileHeight(): number {\n    return this.options?.tileHeight ?? this.baseCoords.height;\n  }\n\n  /**\n   * The `tileId` of the _first_ tile\n   */\n  get firstId(): number {\n    return this.options?.firstId ?? 1;\n  }\n\n  /**\n   * The `tileId` of the _last_ tile\n   */\n  get lastId(): number {\n    return this.firstId + this.tileCount - 1;\n  }\n\n  /**\n   * The `frameId` of the _last_ tile\n   */\n  get lastFrameId(): number {\n    return this.firstFrameId + this.tileCount - 1;\n  }\n\n  get tileCountLimit(): number {\n    return this.options?.tileCount ?? Infinity;\n  }\n\n  get margin(): number {\n    return this.options?.margin ?? 0;\n  }\n\n  get padding(): number {\n    return this.options?.padding ?? 0;\n  }\n\n  get spacing(): number {\n    return this.options?.spacing ?? 0;\n  }\n\n  frameId(tileId: number): number {\n    return ((((tileId - this.firstId) % this.tileCount) + this.tileCount) % this.tileCount) + this.firstFrameId;\n  }\n\n  randomTileId(): number {\n    return this.firstId + rand(this.tileCount);\n  }\n\n  randomFrameId(): number {\n    return this.firstFrameId + rand(this.tileCount);\n  }\n\n  frame(tileId: number): TextureAtlasFrame {\n    return this.atlas.get(this.frameId(tileId));\n  }\n\n  randomFrame(): TextureAtlasFrame {\n    return this.atlas.get(this.randomFrameId());\n  }\n\n  #createTextureCoords = (): void => {\n    const {width: baseWidth, height: baseHeight} = this.baseCoords;\n\n    const {padding, margin, spacing, tileCountLimit} = this;\n\n    const tileOuterWidth = this.tileWidth + (padding << 1);\n    const tileOuterHeight = this.tileHeight + (padding << 1);\n\n    let x = margin;\n    let y = margin;\n    let tileCount = 0;\n\n    while (1) {\n      const coords = new TextureCoords(this.baseCoords, x + padding, y + padding, this.tileWidth, this.tileHeight);\n\n      const frameId = this.atlas.add(coords);\n\n      if (this.firstFrameId === -1) {\n        this.firstFrameId = frameId;\n      }\n\n      ++tileCount;\n\n      if (tileCountLimit !== Infinity && tileCount === tileCountLimit) {\n        break;\n      }\n\n      const xOffsetNext = tileOuterWidth + spacing;\n\n      if (x + xOffsetNext + tileOuterWidth + margin <= baseWidth) {\n        x += xOffsetNext;\n      } else {\n        x = margin;\n        y += tileOuterHeight + spacing;\n        if (y + tileOuterHeight + margin > baseHeight) {\n          break;\n        }\n      }\n    }\n\n    this.tileCount = tileCount;\n  };\n}\n","import {DataTexture, FloatType, RGBAFormat} from 'three';\n\nimport {TextureAtlas} from './TextureAtlas';\nimport {TextureCoords} from './TextureCoords';\nimport {TileSet} from './TileSet';\nimport {findNextPowerOf2} from './findNextPowerOf2';\n\ntype AnimName = string | symbol;\n\n/**\n * @category Texture Mapping\n */\nexport interface FrameBasedAnimDef {\n  frames: TextureCoords[];\n  duration: number;\n  name: AnimName;\n  id: number;\n}\n\n/**\n * @category Texture Mapping\n */\nexport interface BakeTextureOptions {\n  includeTextureSize: boolean;\n}\n\ntype AnimationsMap = Map<AnimName, FrameBasedAnimDef>;\n\nconst getBufferSize = (animationsMap: AnimationsMap, sizePerTexture = 1, maxTextureSize = 16384) => {\n  const anims = Array.from(animationsMap.values());\n  const totalFramesCount = anims.reduce((sum, anim) => sum + anim.frames.length, 0);\n  const minBufSize = anims.length + totalFramesCount * sizePerTexture;\n  const bufSize = findNextPowerOf2(minBufSize);\n\n  if (bufSize > maxTextureSize) {\n    throw new Error('TODO too many animation frames - we need better way here to calculate a corresponding buffer size!');\n  }\n\n  return bufSize;\n};\n\nconst renderFloatsBuffer = (\n  floatsBuffer: Float32Array,\n  names: AnimName[],\n  animations: AnimationsMap,\n  includeTextureSize: boolean,\n) => {\n  let curOffset = names.length;\n\n  floatsBuffer.set(\n    names.flatMap((name) => {\n      const {frames, duration} = animations.get(name);\n      const offset = curOffset;\n      curOffset += frames.length * (includeTextureSize ? 2 : 1);\n      return [frames.length, duration, offset, 0];\n    }),\n  );\n\n  floatsBuffer.set(\n    includeTextureSize\n      ? names.flatMap((name) =>\n          animations.get(name).frames.flatMap(({s, t, u, v, width, height}) => [s, t, u, v, width, height, 0, 0]),\n        )\n      : names.flatMap((name) => animations.get(name).frames.flatMap(({s, t, u, v}) => [s, t, u, v])),\n    names.length * 4,\n  );\n\n  return floatsBuffer;\n};\n\n/**\n * @category Texture Mapping\n */\nexport class FrameBasedAnimations {\n  static MaxTextureSize = 16384;\n\n  #animations: AnimationsMap = new Map();\n\n  // we can not just use animations.keys() here, because we need a consistent name <-> id mapping\n  #names: AnimName[] = [];\n\n  add(\n    // TODO support args without first anim-frame parameter\n    ...args:\n      | [\n          name: AnimName | undefined,\n          duration: number,\n          // TODO support frameRate (fps) option as an alternative to duration\n          texCoords: TextureCoords[],\n        ]\n      | [name: AnimName | undefined, duration: number, atlas: TextureAtlas, frameNameQuery?: string]\n      | [name: AnimName | undefined, duration: number, tileSet: TileSet, firstTileId?: number, tileCount?: number]\n      | [name: AnimName | undefined, duration: number, tileSet: TileSet, tileIds: number[]]\n  ): number {\n    let [name] = args;\n\n    if (name) {\n      if (this.#animations.has(name)) {\n        throw new Error(`name='${name.toString()}' must be unique!`);\n      }\n    } else {\n      name = Symbol('n/a');\n    }\n\n    let frames: TextureCoords[];\n\n    if (Array.isArray(args[2])) {\n      frames = args[2];\n    } else if (args[2] instanceof TextureAtlas) {\n      const atlas = args[2];\n      const frameNames = atlas.frameNames(args[3] as any).sort();\n      frames = frameNames.map((frameName) => atlas.frame(frameName).coords);\n    } else if (args[2] instanceof TileSet) {\n      const tileSet = args[2];\n      if (Array.isArray(args[3])) {\n        const tileIds = args[3];\n        frames = tileIds.map((tileId) => tileSet.frame(tileId).coords);\n      } else {\n        const firstTileId = (args[3] as number | undefined) ?? tileSet.firstId;\n        const tileCount: number = args[4] ?? tileSet.tileCount;\n        frames = [];\n        for (let tileId = firstTileId; tileId < firstTileId + tileCount; tileId++) {\n          frames.push(tileSet.frame(tileId).coords);\n        }\n      }\n    }\n\n    const id = this.#names.length;\n    const [, duration] = args;\n\n    this.#names.push(name);\n    this.#animations.set(name, {\n      id,\n      name,\n      frames,\n      duration,\n    });\n\n    return id;\n  }\n\n  animId(name: AnimName): number {\n    return this.#animations.get(name).id;\n  }\n\n  bakeDataTexture(options?: BakeTextureOptions): DataTexture {\n    const includeTextureSize = Boolean(options?.includeTextureSize);\n\n    const bufSize = getBufferSize(this.#animations, includeTextureSize ? 2 : 1, FrameBasedAnimations.MaxTextureSize);\n\n    const floatsBuffer = renderFloatsBuffer(new Float32Array(bufSize * 4), this.#names, this.#animations, includeTextureSize);\n\n    const dataTexture = new DataTexture(floatsBuffer, bufSize, 1, RGBAFormat, FloatType);\n    dataTexture.needsUpdate = true;\n\n    return dataTexture;\n  }\n}\n","import {VertexObjectDescriptor} from './VertexObjectDescriptor';\nimport {voBuffer} from './constants';\nimport {VO} from './types';\n\n/**\n * @category Vertex Objects\n */\nexport function getDescriptorOf(vo: VO): VertexObjectDescriptor {\n  return vo[voBuffer].descriptor;\n}\n","import {TypedArray, VertexAttributeDataType} from './types';\n\nexport function createTypedArray(dataType: VertexAttributeDataType, size: number): TypedArray {\n  switch (dataType) {\n    case 'float64':\n      return new Float64Array(size);\n    case 'float32':\n      return new Float32Array(size);\n    case 'float16':\n      return new Uint16Array(size);\n    case 'uint32':\n      return new Uint32Array(size);\n    case 'int32':\n      return new Int32Array(size);\n    case 'uint16':\n      return new Uint16Array(size);\n    case 'int16':\n      return new Int16Array(size);\n    case 'uint8':\n      return new Uint8Array(size);\n    case 'uint8clamped':\n      return new Uint8ClampedArray(size);\n    case 'int8':\n      return new Int8Array(size);\n    default:\n      throw new Error(`unknown typed-array data-type: '${dataType}'`);\n  }\n}\n","import {VertexObjectBuffer} from './VertexObjectBuffer';\nimport {voBuffer, voIndex} from './constants';\nimport {createTypedArray} from './createTypedArray';\nimport {VO} from './types';\n\nconst toPascalCase = (str: string) => str.replace(/(^|_)([a-z])/g, (_match: string, _m0: string, m1: string) => m1.toUpperCase());\n\nconst makeAttributeGetter = (bufferName: string, instanceOffset: number, attrOffset: number) => {\n  return function getAttribute(this: VO) {\n    const idx = this[voIndex] * instanceOffset + attrOffset;\n    const buf = this[voBuffer].buffers.get(bufferName);\n    return buf.typedArray[idx];\n  };\n};\n\nconst makeAttributeSetter = (bufferName: string, instanceOffset: number, attrOffset: number) => {\n  return function setAttribute(this: VO, value: number) {\n    const idx = this[voIndex] * instanceOffset + attrOffset;\n    const buf = this[voBuffer].buffers.get(bufferName);\n    buf.typedArray[idx] = value;\n  };\n};\n\nconst makeAttributeValuesGetter = (\n  bufferName: string,\n  bufferItemSize: number,\n  vertexCount: number,\n  attrOffset: number,\n  attrSize: number,\n) => {\n  return function getAttributeValues(this: VO) {\n    const idx = this[voIndex] * vertexCount * bufferItemSize + attrOffset;\n    const buf = this[voBuffer].buffers.get(bufferName);\n    const source = buf.typedArray;\n    const target = createTypedArray(buf.dataType, vertexCount * attrSize);\n    for (let i = 0; i < vertexCount; i++) {\n      if (attrSize === 1) {\n        target[i] = source[idx + i * bufferItemSize];\n      } else {\n        target.set(source.subarray(idx + i * bufferItemSize, idx + i * bufferItemSize + attrSize), i * attrSize);\n      }\n    }\n    return target;\n  };\n};\n\nconst makeAttributeValueSetter = (\n  bufferName: string,\n  bufferItemSize: number,\n  vertexCount: number,\n  attrOffset: number,\n  attrSize: number,\n) => {\n  return function setAttributeValues(this: VO, ...values: number[] | [ArrayLike<number>]) {\n    const source = values.length === 1 && Array.isArray(values[0]) ? values[0] : values;\n    const idx = this[voIndex] * vertexCount * bufferItemSize + attrOffset;\n    const target = this[voBuffer].buffers.get(bufferName).typedArray;\n    for (let i = 0; i < vertexCount; i++) {\n      if (attrSize === 1) {\n        target[idx + i * bufferItemSize] = source[i];\n      } else {\n        target.set(Array.prototype.slice.call(source, i * attrSize, i * attrSize + attrSize), idx + i * bufferItemSize);\n      }\n    }\n  };\n};\n\nexport function createVertexObjectPrototype(voBuffer: VertexObjectBuffer, basePrototype: Object | null | undefined): Object {\n  const {descriptor} = voBuffer;\n  const props = Object.fromEntries(\n    descriptor.attributeNames.flatMap((attrName) => {\n      const attr = descriptor.getAttribute(attrName);\n      const bufAttr = voBuffer.bufferAttributes.get(attrName);\n      const buf = voBuffer.buffers.get(bufAttr.bufferName);\n      const AttrName = toPascalCase(attrName);\n\n      const methods: any[] = [];\n      if (descriptor.vertexCount === 1 && attr.size === 1) {\n        methods.push([\n          attrName,\n          {\n            enumerable: true,\n            get: makeAttributeGetter(bufAttr.bufferName, buf.itemSize, bufAttr.offset),\n            set: makeAttributeSetter(bufAttr.bufferName, buf.itemSize, bufAttr.offset),\n          },\n        ]);\n      } else {\n        methods.push(\n          [\n            `get${AttrName}`,\n            {\n              enumerable: true,\n              value: makeAttributeValuesGetter(\n                bufAttr.bufferName,\n                buf.itemSize,\n                descriptor.vertexCount,\n                bufAttr.offset,\n                attr.size,\n              ),\n            },\n          ],\n          [\n            `set${AttrName}`,\n            {\n              enumerable: true,\n              value: makeAttributeValueSetter(\n                bufAttr.bufferName,\n                buf.itemSize,\n                descriptor.vertexCount,\n                bufAttr.offset,\n                attr.size,\n              ),\n            },\n          ],\n        );\n      }\n      if (attr.hasComponents) {\n        attr.components.forEach((component, componentIndex) => {\n          for (let vertexIndex = 0; vertexIndex < descriptor.vertexCount; vertexIndex++) {\n            const instanceOffset = descriptor.vertexCount * buf.itemSize;\n            const attrOffset = vertexIndex * buf.itemSize + bufAttr.offset + componentIndex;\n            if (descriptor.vertexCount > 1 || component !== attr.name) {\n              methods.push([\n                `${component}${descriptor.vertexCount === 1 ? '' : vertexIndex}`,\n                {\n                  enumerable: true,\n                  get: makeAttributeGetter(bufAttr.bufferName, instanceOffset, attrOffset),\n                  set: makeAttributeSetter(bufAttr.bufferName, instanceOffset, attrOffset),\n                },\n              ]);\n            }\n          }\n        });\n      }\n      return methods;\n    }),\n  );\n  return Object.create(basePrototype !== undefined ? basePrototype : Object.prototype, props);\n}\n","import {VertexObjectDescriptor} from './VertexObjectDescriptor';\nimport {createTypedArray} from './createTypedArray';\nimport {createVertexObjectPrototype} from './createVertexObjectPrototype';\nimport {TypedArray, VertexAttributeDataType, VertexAttributeUsageType} from './types';\n\nimport {VertexObjectBuffersData} from '.';\n\ninterface BufferAttribute {\n  bufferName: string;\n  attributeName: string;\n  offset: number;\n}\n\ninterface Buffer {\n  bufferName: string;\n  itemSize: number;\n  dataType: VertexAttributeDataType;\n  usageType: VertexAttributeUsageType;\n  typedArray: TypedArray;\n  // serial?\n  // needsUpdate?\n  // autoTouch\n  // THREE->bufferAttribute?\n}\n\n/**\n * @category Vertex Objects\n */\nexport class VertexObjectBuffer {\n  readonly descriptor: VertexObjectDescriptor;\n  readonly capacity: number;\n\n  /** the names are always sorted the same way */\n  readonly attributeNames: readonly string[];\n\n  readonly buffers: Map<string, Buffer>;\n  readonly bufferAttributes: Map<string, BufferAttribute>;\n\n  /** buffer name -> list of buffer attributes */\n  readonly bufferNameAttributes: Map<string, BufferAttribute[]>;\n\n  constructor(source: VertexObjectDescriptor | VertexObjectBuffer, capacityOrBuffersData: number | VertexObjectBuffersData) {\n    let buffersData: VertexObjectBuffersData | undefined;\n    if (typeof capacityOrBuffersData === 'number') {\n      this.capacity = capacityOrBuffersData;\n    } else {\n      buffersData = capacityOrBuffersData;\n      this.capacity = buffersData.capacity;\n    }\n\n    if (source instanceof VertexObjectBuffer) {\n      this.descriptor = source.descriptor;\n      this.attributeNames = source.attributeNames;\n      this.bufferAttributes = source.bufferAttributes;\n      this.bufferNameAttributes = source.bufferNameAttributes;\n      this.buffers = new Map();\n\n      for (const [bufferName, buffer] of source.buffers) {\n        this.buffers.set(bufferName, {\n          bufferName,\n          itemSize: buffer.itemSize,\n          dataType: buffer.dataType,\n          usageType: buffer.usageType,\n          typedArray: createTypedArray(buffer.dataType, this.capacity * this.descriptor.vertexCount * buffer.itemSize),\n        });\n      }\n    } else {\n      this.descriptor = source;\n      this.buffers = new Map();\n      this.bufferAttributes = new Map();\n      this.attributeNames = Object.freeze(Array.from(this.descriptor.attributeNames).sort());\n\n      for (const attributeName of this.attributeNames) {\n        const attribute = this.descriptor.getAttribute(attributeName);\n        const {bufferName} = attribute;\n        let offset = 0;\n        if (this.buffers.has(bufferName)) {\n          const buffer = this.buffers.get(bufferName);\n          offset = buffer.itemSize;\n          buffer.itemSize += attribute.size;\n        } else {\n          this.buffers.set(bufferName, {\n            bufferName,\n            itemSize: attribute.size,\n            dataType: attribute.dataType,\n            usageType: attribute.usageType,\n            typedArray: undefined,\n          });\n        }\n        this.bufferAttributes.set(attributeName, {\n          bufferName,\n          attributeName,\n          offset,\n        });\n      }\n\n      for (const buffer of this.buffers.values()) {\n        buffer.typedArray =\n          buffersData?.buffers[buffer.bufferName] ??\n          createTypedArray(buffer.dataType, this.capacity * this.descriptor.vertexCount * buffer.itemSize);\n      }\n\n      this.bufferNameAttributes = new Map();\n      for (const bufAttr of this.bufferAttributes.values()) {\n        const {bufferName} = bufAttr;\n        if (this.bufferNameAttributes.has(bufferName)) {\n          this.bufferNameAttributes.get(bufferName).push(bufAttr);\n        } else {\n          this.bufferNameAttributes.set(bufferName, [bufAttr]);\n        }\n      }\n    }\n\n    if (!this.descriptor.voPrototype) {\n      this.descriptor.voPrototype = createVertexObjectPrototype(this, this.descriptor.basePrototype);\n    }\n  }\n\n  copy(otherVob: VertexObjectBuffer, objectOffset = 0): void {\n    const {vertexCount} = this.descriptor;\n    for (const {bufferName, typedArray, itemSize} of this.buffers.values()) {\n      typedArray.set(otherVob.buffers.get(bufferName).typedArray, objectOffset * vertexCount * itemSize);\n    }\n  }\n\n  clone(): VertexObjectBuffer {\n    const clone = new VertexObjectBuffer(this, this.capacity);\n    clone.copy(this);\n    return clone;\n  }\n\n  copyWithin(target: number, start: number, end = this.capacity): void {\n    const {vertexCount} = this.descriptor;\n    for (const {typedArray, itemSize} of this.buffers.values()) {\n      typedArray.copyWithin(target * vertexCount * itemSize, start * vertexCount * itemSize, end * vertexCount * itemSize);\n    }\n  }\n\n  copyAttributes(attributes: Record<string, ArrayLike<number>>, objectOffset = 0): number {\n    let copiedObjCount = 0;\n    for (const [attrName, data] of Object.entries(attributes)) {\n      const attr = this.bufferAttributes.get(attrName);\n      if (attr) {\n        let attrObjCount = 0;\n        const buffer = this.buffers.get(attr.bufferName);\n        const {vertexCount} = this.descriptor;\n        const attrSize = this.descriptor.getAttribute(attrName).size;\n        let idx = 0;\n        let bufIdx = objectOffset * vertexCount * buffer.itemSize;\n        while (idx < data.length && attrObjCount + objectOffset < this.capacity) {\n          for (let i = 0; i < vertexCount; i++) {\n            buffer.typedArray.set(Array.prototype.slice.call(data, idx, idx + attrSize), bufIdx + attr.offset);\n            idx += attrSize;\n            bufIdx += buffer.itemSize;\n          }\n          ++attrObjCount;\n        }\n        if (attrObjCount > copiedObjCount) {\n          copiedObjCount = attrObjCount;\n        }\n      }\n    }\n    return copiedObjCount;\n  }\n\n  toAttributeArrays(attributeNames: string[], start = 0, end = this.capacity): Record<string, TypedArray> {\n    return Object.fromEntries(\n      attributeNames.map((attrName) => {\n        const attr = this.bufferAttributes.get(attrName);\n        if (attr) {\n          const buffer = this.buffers.get(attr.bufferName);\n          const {vertexCount} = this.descriptor;\n          const attrSize = this.descriptor.getAttribute(attrName).size;\n\n          const targetArray = createTypedArray(buffer.dataType, (end - start) * vertexCount * attrSize);\n\n          let targetIdx = 0;\n          let bufferIdx = start * vertexCount * buffer.itemSize + attr.offset;\n\n          for (let objIdx = start; objIdx < end; objIdx++) {\n            for (let i = 0; i < vertexCount; i++) {\n              targetArray.set(buffer.typedArray.subarray(bufferIdx, bufferIdx + attrSize), targetIdx);\n              targetIdx += attrSize;\n              bufferIdx += buffer.itemSize;\n            }\n          }\n          return [attrName, targetArray];\n        }\n        return [attrName];\n      }),\n    );\n  }\n}\n","import {VertexAttributeDataType, VertexAttributeDescription, VertexAttributeUsageType} from './types';\n\n/**\n * @category Vertex Objects\n */\nexport class VertexAttributeDescriptor {\n  private readonly description: VertexAttributeDescription;\n\n  readonly name: string;\n\n  constructor(name: string, description: VertexAttributeDescription) {\n    this.name = name;\n    this.description = description;\n  }\n\n  get dataType(): VertexAttributeDataType {\n    return this.description.type ?? 'float32';\n  }\n\n  get normalizedData(): boolean {\n    return Boolean(this.description.normalized);\n  }\n\n  get usageType(): VertexAttributeUsageType {\n    return this.description.usage ?? 'static';\n  }\n\n  get autoTouch(): boolean {\n    return this.description.autoTouch ?? this.usageType !== 'static';\n  }\n\n  get size(): number {\n    // @ts-ignore\n    return this.description.size ?? this.description.components?.length ?? 1;\n  }\n\n  get hasComponents(): boolean {\n    // @ts-ignore\n    return this.description.components?.length > 0;\n  }\n\n  get components(): string[] {\n    // @ts-ignore\n    return this.description.components ?? [];\n  }\n\n  get bufferName(): string {\n    return `${this.usageType}_${this.dataType}${this.normalizedData ? 'N' : ''}`;\n  }\n}\n","import {VertexAttributeDescriptor} from './VertexAttributeDescriptor';\nimport {VertexObjectDescription} from './types';\n\n/**\n * @category Vertex Objects\n */\nexport class VertexObjectDescriptor {\n  private readonly description: VertexObjectDescription;\n\n  readonly attributes: Map<string, VertexAttributeDescriptor>;\n  readonly bufferNames: Set<string>;\n  readonly basePrototype: Object | null | undefined;\n\n  voPrototype: Object; // initialization is delayed and is done by ..\n  // .. the first VertexObjectBuffer that uses this descriptor\n  // TODO add test for this case\n\n  constructor(description: VertexObjectDescription) {\n    this.description = description;\n    this.attributes = new Map();\n    this.bufferNames = new Set();\n    Object.entries(this.description.attributes).forEach(([attrName, attrDesc]) => {\n      const descriptor = new VertexAttributeDescriptor(attrName, attrDesc);\n      this.attributes.set(attrName, descriptor);\n      this.bufferNames.add(descriptor.bufferName);\n    });\n    this.basePrototype = description.basePrototype;\n  }\n\n  /** Returns `vertexCount` or `1` */\n  get vertexCount(): number {\n    return this.description.vertexCount ?? 1;\n  }\n\n  /** Returns `meshCount` or `1` */\n  get meshCount(): number {\n    return this.description.meshCount ?? 1;\n  }\n\n  /**\n   * Calculate the instance count if your `meshCount` is greater than 1,\n   * otherwise return the given capacity\n   * TODO remove?!\n   */\n  getInstanceCount(capacity: number): number {\n    const meshCount = this.description.meshCount ?? 1;\n    return meshCount > 1 ? Math.ceil(capacity / meshCount) : capacity;\n  }\n\n  get hasIndices(): boolean {\n    return this.description.indices?.length > 0;\n  }\n\n  get indices(): number[] {\n    return this.description.indices ?? [];\n  }\n\n  get attributeNames(): string[] {\n    return Array.from(this.attributes.keys());\n  }\n\n  getAttribute(name: string): VertexAttributeDescriptor | undefined {\n    return this.attributes.get(name);\n  }\n}\n","import {VertexObjectBuffer} from './VertexObjectBuffer';\nimport {VertexObjectDescriptor} from './VertexObjectDescriptor';\nimport {voBuffer, voIndex} from './constants';\nimport {VertexObjectDescription, VO} from './types';\n\nimport {VertexObjectBuffersData} from '.';\n\nconst createVertexObject = (descriptor: VertexObjectDescriptor, buffer: VertexObjectBuffer, objectIndex: number) =>\n  Object.create(descriptor.voPrototype, {\n    [voBuffer]: {\n      value: buffer,\n      writable: true,\n    },\n    [voIndex]: {\n      value: objectIndex,\n      writable: true,\n    },\n  });\n\n/**\n * @category Vertex Objects\n */\nexport class VertexObjectPool<VOType = VO> {\n  static setVoIndex(vo: VO, idx: number): VO {\n    vo[voIndex] = idx;\n    return vo;\n  }\n\n  readonly descriptor: VertexObjectDescriptor;\n  readonly capacity: number;\n\n  buffer: VertexObjectBuffer;\n\n  #index: Array<VOType & VO>;\n  #usedCount = 0;\n\n  constructor(descriptor: VertexObjectDescriptor | VertexObjectDescription, capacityOrData: number | VertexObjectBuffersData) {\n    this.descriptor = descriptor instanceof VertexObjectDescriptor ? descriptor : new VertexObjectDescriptor(descriptor);\n    if (typeof capacityOrData === 'number') {\n      const capacity = capacityOrData;\n      this.capacity = capacity;\n      this.buffer = new VertexObjectBuffer(this.descriptor, capacity);\n    } else {\n      const buffersData = capacityOrData;\n      this.capacity = buffersData.capacity;\n      this.#usedCount = buffersData.usedCount;\n      this.buffer = new VertexObjectBuffer(this.descriptor, buffersData);\n    }\n    this.#index = new Array(this.capacity);\n  }\n\n  get usedCount(): number {\n    return this.#usedCount;\n  }\n\n  set usedCount(value: number) {\n    // TODO test\n    if (value < this.#usedCount) {\n      this.#index.fill(undefined, value, this.#usedCount);\n    }\n    this.#usedCount = value < this.capacity ? value : this.capacity;\n  }\n\n  get availableCount(): number {\n    return this.capacity - this.#usedCount;\n  }\n\n  clear(): void {\n    this.usedCount = 0;\n  }\n\n  createVO(): VOType & VO {\n    if (this.#usedCount < this.capacity) {\n      const idx = this.usedCount++;\n      const vo = createVertexObject(this.descriptor, this.buffer, idx);\n      this.#index[idx] = vo;\n      return vo;\n    }\n  }\n\n  createFromAttributes(attributes: Record<string, ArrayLike<number>>): [objectCount: number, firstObjectIdx: number] {\n    const firstObjectIdx = this.#usedCount;\n    const objectCount = this.buffer.copyAttributes(attributes, firstObjectIdx);\n    this.#usedCount += objectCount;\n    return [objectCount, firstObjectIdx];\n  }\n\n  /**\n   * The fastest variant is when the VO was the last one created,\n   * otherwise the underlying buffer(s) have to be recopied internally.\n   */\n  freeVO(vo: VO): void {\n    if (vo[voBuffer] === this.buffer) {\n      const idx = vo[voIndex];\n      const lastUsedIdx = this.#usedCount - 1;\n      if (idx === lastUsedIdx) {\n        this.#index[idx] = undefined;\n      } else {\n        this.buffer.copyWithin(idx, lastUsedIdx, lastUsedIdx + 1);\n        const lastUsedVO = this.#index[lastUsedIdx];\n        lastUsedVO[voIndex] = idx;\n        this.#index[idx] = lastUsedVO;\n      }\n      this.usedCount--;\n      vo[voBuffer] = undefined;\n    }\n  }\n\n  getVO(idx: number): (VOType & VO) | undefined {\n    let vo = this.#index[idx];\n    if (vo == null && idx < this.#usedCount) {\n      vo = createVertexObject(this.descriptor, this.buffer, idx);\n      this.#index[idx] = vo;\n    }\n    return vo;\n  }\n\n  toBuffersData(): VertexObjectBuffersData {\n    return {\n      capacity: this.capacity,\n      usedCount: this.usedCount,\n      buffers: Object.fromEntries(\n        Array.from(this.buffer.buffers.values()).map((buffer) => [buffer.bufferName, buffer.typedArray]),\n      ),\n    };\n  }\n}\n","import {DynamicDrawUsage, StaticDrawUsage, StreamDrawUsage} from 'three';\n\nimport {DrawUsageType, VertexAttributeUsageType} from './types';\n\nexport function toDrawUsage(usage: VertexAttributeUsageType): DrawUsageType {\n  switch (usage) {\n    case 'dynamic':\n      return DynamicDrawUsage;\n    case 'stream':\n      return StreamDrawUsage;\n    default:\n      return StaticDrawUsage;\n  }\n}\n","import {BufferAttribute, BufferGeometry, InterleavedBuffer, InterleavedBufferAttribute} from 'three';\n\nimport {VertexObjectPool} from './VertexObjectPool';\nimport {createIndicesArray} from './createIndicesArray';\nimport {toDrawUsage} from './toDrawUsage';\nimport {BufferLike} from './types';\n\nexport function initializeAttributes(geometry: BufferGeometry, pool: VertexObjectPool, buffers: Map<string, BufferLike>): void {\n  const {descriptor, capacity} = pool;\n  if (descriptor.hasIndices) {\n    const {indices} = descriptor;\n    const bufAttr = new BufferAttribute(createIndicesArray(indices, capacity), 3);\n    bufAttr.count = capacity * indices.length;\n    geometry.setIndex(bufAttr);\n  }\n  for (const buffer of pool.buffer.buffers.values()) {\n    const attributes = pool.buffer.bufferNameAttributes.get(buffer.bufferName);\n    if (attributes.length > 1) {\n      const interleavedBuffer = new InterleavedBuffer(buffer.typedArray, buffer.itemSize);\n      interleavedBuffer.setUsage(toDrawUsage(buffer.usageType));\n      buffers.set(buffer.bufferName, interleavedBuffer);\n      for (const bufAttr of attributes) {\n        const attrDesc = descriptor.attributes.get(bufAttr.attributeName);\n        const attr = new InterleavedBufferAttribute(interleavedBuffer, attrDesc.size, bufAttr.offset, attrDesc.normalizedData);\n        attr.name = bufAttr.attributeName;\n        geometry.setAttribute(attrDesc.name, attr);\n      }\n    } else {\n      const bufAttr = attributes[0];\n      const attrDesc = descriptor.attributes.get(bufAttr.attributeName);\n      const attr = new BufferAttribute(buffer.typedArray, buffer.itemSize, attrDesc.normalizedData);\n      attr.setUsage(toDrawUsage(buffer.usageType));\n      attr.name = bufAttr.attributeName;\n      buffers.set(buffer.bufferName, attr);\n      geometry.setAttribute(attrDesc.name, attr);\n    }\n  }\n}\n","export function createIndicesArray(indices: number[], count: number): Uint32Array {\n  const itemCount = indices.length;\n  const arr = new Uint32Array(count * itemCount);\n  const stride = Math.max(...indices) + 1;\n\n  for (let i = 0; i < count; i++) {\n    for (let j = 0; j < itemCount; j++) {\n      arr[i * itemCount + j] = indices[j] + i * stride;\n    }\n  }\n\n  return arr;\n}\n","import {VertexObjectPool} from './VertexObjectPool';\nimport {BufferLike} from './types';\n\nexport function selectAttributes(pool: VertexObjectPool, buffers: Map<string, BufferLike>, attrNames: string[]): BufferLike[] {\n  const attrs = new Set<string>();\n  for (const name of attrNames) {\n    const bufAttr = pool.buffer.bufferAttributes.get(name);\n    if (bufAttr) {\n      attrs.add(bufAttr.bufferName);\n    }\n  }\n  return Array.from(attrs.values()).map((bufferName) => buffers.get(bufferName));\n}\n","import {toDrawUsage} from './toDrawUsage';\nimport {BufferLike, VertexAttributeUsageType} from './types';\n\nexport function selectBuffers(\n  buffers: Map<string, BufferLike>,\n  bufferTypes: {\n    [Type in VertexAttributeUsageType]?: boolean;\n  },\n): BufferLike[] {\n  const results = [];\n  for (const [usageType, needsUpdate] of Object.entries(bufferTypes)) {\n    if (needsUpdate === true) {\n      const drawUsage = toDrawUsage(usageType as VertexAttributeUsageType);\n      results.push(...Array.from(buffers.values()).filter((buffer) => buffer.usage === drawUsage));\n    }\n  }\n  return results;\n}\n","import {BufferGeometry, InstancedBufferGeometry} from 'three';\n\nimport {VertexObjectDescriptor} from './VertexObjectDescriptor';\nimport {VertexObjectPool} from './VertexObjectPool';\nimport {initializeAttributes} from './initializeAttributes';\nimport {initializeInstancedAttributes} from './initializeInstancedAttributes';\nimport {selectAttributes} from './selectAttributes';\nimport {selectBuffers} from './selectBuffers';\nimport {BufferLike, VertexAttributeUsageType, VertexObjectDescription, VO} from './types';\n\ntype TouchBuffersType = {[Type in VertexAttributeUsageType]?: boolean};\n\ntype TouchInstancedBuffersType = {\n  base?: TouchBuffersType;\n  instanced?: TouchBuffersType;\n};\n\n/**\n * @category Vertex Objects\n */\nexport class InstancedVertexObjectGeometry<\n  VOInstancedType extends VO = VO,\n  VOBaseType extends VO = VO,\n> extends InstancedBufferGeometry {\n  readonly basePool?: VertexObjectPool<VOBaseType>;\n  readonly baseBuffers?: Map<string, BufferLike>;\n\n  readonly instancedPool: VertexObjectPool<VOInstancedType>;\n  readonly instancedBuffers: Map<string, BufferLike> = new Map();\n\n  constructor(\n    ...args:\n      | [VertexObjectPool<VOInstancedType> | VertexObjectDescriptor | VertexObjectDescription, number, BufferGeometry]\n      | [\n          VertexObjectPool<VOInstancedType> | VertexObjectDescriptor | VertexObjectDescription,\n          number,\n          VertexObjectPool<VOBaseType> | VertexObjectDescriptor | VertexObjectDescription,\n          number?,\n        ]\n  ) {\n    super();\n    const [instancedSource, instancedCapacity] = args;\n    this.instancedPool =\n      instancedSource instanceof VertexObjectPool ? instancedSource : new VertexObjectPool(instancedSource, instancedCapacity);\n    this.name = 'InstancedVertexObjectGeometry';\n    if (args[2] instanceof BufferGeometry) {\n      this.copy(args[2]);\n    } else {\n      const baseSource = args[2];\n      const baseCapacity = args[3] ?? 1;\n      this.basePool = baseSource instanceof VertexObjectPool ? baseSource : new VertexObjectPool(baseSource, baseCapacity);\n      this.baseBuffers = new Map();\n      initializeAttributes(this, this.basePool, this.baseBuffers);\n    }\n    initializeInstancedAttributes(this, this.instancedPool, this.instancedBuffers);\n  }\n\n  dispose(): void {\n    this.basePool?.clear();\n    this.instancedPool.clear();\n    super.dispose();\n  }\n\n  touchAttributes(...attrNames: string[]): void {\n    if (this.basePool) {\n      selectAttributes(this.basePool, this.baseBuffers, attrNames).forEach((buffer) => {\n        buffer.needsUpdate = true;\n      });\n    }\n    selectAttributes(this.instancedPool, this.instancedBuffers, attrNames).forEach((buffer) => {\n      buffer.needsUpdate = true;\n    });\n  }\n\n  touchBuffers(bufferTypes: TouchInstancedBuffersType | TouchBuffersType): void {\n    if ('base' in bufferTypes || 'instanced' in bufferTypes) {\n      if (bufferTypes.base && this.baseBuffers) {\n        selectBuffers(this.baseBuffers, bufferTypes.base).forEach((buffer) => {\n          buffer.needsUpdate = true;\n        });\n      }\n      if (bufferTypes.instanced) {\n        selectBuffers(this.instancedBuffers, bufferTypes.instanced).forEach((buffer) => {\n          buffer.needsUpdate = true;\n        });\n      }\n    } else {\n      selectBuffers(this.instancedBuffers, bufferTypes as TouchBuffersType).forEach((buffer) => {\n        buffer.needsUpdate = true;\n      });\n    }\n  }\n\n  touch(...args: Array<string | TouchBuffersType | TouchInstancedBuffersType>): void {\n    const attrNames: string[] = [];\n    let buffers: TouchBuffersType | TouchInstancedBuffersType;\n    args.forEach((arg) => {\n      if (typeof arg === 'string') {\n        attrNames.push(arg);\n      } else {\n        buffers = {...buffers, ...arg};\n      }\n    });\n    if (attrNames.length) {\n      this.touchAttributes(...attrNames);\n    }\n    if (buffers) {\n      this.touchBuffers(buffers);\n    }\n  }\n\n  update(): void {\n    this.#autoTouchAttributes();\n    this.#updateDrawRange();\n    this.instanceCount = this.instancedPool.usedCount;\n  }\n\n  #updateDrawRange = (): void => {\n    if (this.basePool) {\n      this.setDrawRange(\n        0,\n        this.basePool.descriptor.hasIndices\n          ? this.basePool.usedCount * this.basePool.descriptor.indices.length\n          : this.basePool.usedCount * this.basePool.descriptor.vertexCount,\n      );\n    } else {\n      this.setDrawRange(0, Infinity);\n    }\n  };\n\n  #autoTouchAttributes = (): void => {\n    const autoTouchAttrs = this.#getAutoTouchAttributeNames();\n    if (autoTouchAttrs.length) {\n      this.touchAttributes(...autoTouchAttrs);\n    }\n  };\n\n  #autoTouchAttrNames?: string[];\n\n  #getAutoTouchAttributeNames = (): string[] => {\n    if (!this.#autoTouchAttrNames) {\n      const attrNames = [...Array.from(this.instancedPool.descriptor.attributes.values())];\n      if (this.basePool) {\n        attrNames.push(...Array.from(this.basePool.descriptor.attributes.values()));\n      }\n      this.#autoTouchAttrNames = attrNames.filter((attr) => attr.autoTouch).map((attr) => attr.name);\n    }\n    return this.#autoTouchAttrNames;\n  };\n}\n","import {BufferGeometry, InstancedBufferAttribute, InstancedInterleavedBuffer, InterleavedBufferAttribute} from 'three';\n\nimport {VertexObjectPool} from './VertexObjectPool';\nimport {toDrawUsage} from './toDrawUsage';\nimport {BufferLike} from './types';\n\nexport function initializeInstancedAttributes(\n  geometry: BufferGeometry,\n  pool: VertexObjectPool,\n  buffers: Map<string, BufferLike>,\n): void {\n  const {descriptor} = pool;\n  const meshPerAttribute = descriptor.meshCount;\n  for (const buffer of pool.buffer.buffers.values()) {\n    const attributes = pool.buffer.bufferNameAttributes.get(buffer.bufferName);\n    if (attributes.length > 1) {\n      const interleavedBuffer = new InstancedInterleavedBuffer(buffer.typedArray, buffer.itemSize, meshPerAttribute);\n      interleavedBuffer.setUsage(toDrawUsage(buffer.usageType));\n      buffers.set(buffer.bufferName, interleavedBuffer);\n      for (const bufAttr of attributes) {\n        const attrDesc = descriptor.attributes.get(bufAttr.attributeName);\n        const attr = new InterleavedBufferAttribute(interleavedBuffer, attrDesc.size, bufAttr.offset, attrDesc.normalizedData);\n        attr.name = bufAttr.attributeName;\n        geometry.setAttribute(attrDesc.name, attr);\n      }\n    } else {\n      const bufAttr = attributes[0];\n      const attrDesc = descriptor.attributes.get(bufAttr.attributeName);\n      const attr = new InstancedBufferAttribute(buffer.typedArray, buffer.itemSize, attrDesc.normalizedData, meshPerAttribute);\n      attr.setUsage(toDrawUsage(buffer.usageType));\n      attr.name = bufAttr.attributeName;\n      buffers.set(buffer.bufferName, attr);\n      geometry.setAttribute(attrDesc.name, attr);\n    }\n  }\n}\n","export const isPowerOf2 = (n: number): boolean => n !== 0 && (n & (n - 1)) === 0;\n","import {ImageLoader} from 'three';\n\nimport {TextureCoords} from './TextureCoords';\nimport {findNextPowerOf2} from './findNextPowerOf2';\nimport {isPowerOf2} from './isPowerOf2';\n\n/**\n * @category Texture Mapping\n */\nexport interface ImageWithTexCoords {\n  imgEl: HTMLImageElement | HTMLCanvasElement;\n  texCoords: TextureCoords;\n}\n\ntype OnImageLoadCallback = (image: ImageWithTexCoords) => void;\ntype OnErrorCallback = ((event: Event) => void) | undefined;\n\n/**\n * @category Texture Mapping\n */\nexport class PowerOf2ImageLoader {\n  #imageLoader?: ImageLoader;\n\n  get imageLoader(): ImageLoader {\n    if (!this.#imageLoader) {\n      this.#imageLoader = new ImageLoader();\n    }\n    return this.#imageLoader;\n  }\n\n  set imageLoader(loader: ImageLoader) {\n    this.#imageLoader = loader;\n  }\n\n  load(url: string, onLoadCallback: OnImageLoadCallback, onErrorCallback?: OnErrorCallback): void {\n    this.imageLoader.load(\n      url,\n      (img: HTMLImageElement) => {\n        if (!isPowerOf2(img.width) || !isPowerOf2(img.height)) {\n          const width = findNextPowerOf2(img.width);\n          const height = findNextPowerOf2(img.height);\n\n          const canvas = document.createElement('canvas');\n          canvas.width = width;\n          canvas.height = height;\n          canvas.getContext('2d').drawImage(img, 0, 0);\n\n          const imgTexCoords = new TextureCoords(0, 0, width, height);\n          const texCoords = new TextureCoords(imgTexCoords, 0, 0, img.width, img.height);\n\n          onLoadCallback({imgEl: canvas, texCoords});\n        } else {\n          onLoadCallback({\n            imgEl: img,\n            texCoords: new TextureCoords(0, 0, img.width, img.height),\n          });\n        }\n      },\n      undefined,\n      onErrorCallback,\n    );\n  }\n\n  loadAsync(url: string): Promise<ImageWithTexCoords> {\n    return new Promise((resolve, reject) => {\n      this.load(url, resolve, reject);\n    });\n  }\n}\n","const isNumber = (x: string | number): x is number => typeof x === 'number';\n\nfunction add(a: string | number, b: string | number): string | number {\n  if (isNumber(a) && isNumber(b)) {\n    return a + b;\n  } else if (isNumber(a)) {\n    switch (a) {\n      case 0:\n        return b;\n      default:\n        return `${a} + ${b}`;\n    }\n  } else if (isNumber(b)) {\n    switch (b) {\n      case 0:\n        return a;\n      default:\n        return `${a} + ${b}`;\n    }\n  } else {\n    return `${a} + ${b}`;\n  }\n}\n\nfunction sub(a: string | number, b: string | number): string | number {\n  if (isNumber(a) && isNumber(b)) {\n    return a - b;\n  } else if (isNumber(a)) {\n    switch (a) {\n      case 0:\n        return `-${b}`;\n      default:\n        return `${a} - ${b}`;\n    }\n  } else if (isNumber(b)) {\n    switch (b) {\n      case 0:\n        return a;\n      default:\n        return `${a} - ${b}`;\n    }\n  } else {\n    return `${a} - ${b}`;\n  }\n}\n\nfunction mul(a: string | number, b: string | number): string | number {\n  if (isNumber(b) && isNumber(a)) {\n    return a * b;\n  } else if (isNumber(a)) {\n    switch (a) {\n      case 0:\n        return 0;\n      case 1:\n        return b;\n      default:\n        return `${a} * ${b}`;\n    }\n  } else if (isNumber(b)) {\n    switch (b) {\n      case 0:\n        return 0;\n      case 1:\n        return a;\n      default:\n        return `${a} * ${b}`;\n    }\n  } else {\n    return `${a} * ${b}`;\n  }\n}\n\nfunction asFloat(number: string | number): string {\n  const str = `${number}`.trim();\n  if (str.match(/^[0-9]+$/)) {\n    return `${str}.0`;\n  }\n  return str;\n}\n\nconst ret = (res: string): string => `return ${res};`;\n\nfunction mat4(\n  m00: string | number = 0,\n  m01: string | number = 0,\n  m02: string | number = 0,\n  m03: string | number = 0,\n  m10: string | number = 0,\n  m11: string | number = 0,\n  m12: string | number = 0,\n  m13: string | number = 0,\n  m20: string | number = 0,\n  m21: string | number = 0,\n  m22: string | number = 0,\n  m23: string | number = 0,\n  m30: string | number = 0,\n  m31: string | number = 0,\n  m32: string | number = 0,\n  m33: string | number = 1,\n  as = asFloat,\n): string {\n  const toStr = as || ((x) => `${x}`);\n  return `mat4(${toStr(m00)}, ${toStr(m01)}, ${toStr(m02)}, ${toStr(m03)}, ${toStr(m10)}, ${toStr(m11)}, ${toStr(m12)}, ${toStr(\n    m13,\n  )}, ${toStr(m20)}, ${toStr(m21)}, ${toStr(m22)}, ${toStr(m23)}, ${toStr(m30)}, ${toStr(m31)}, ${toStr(m32)}, ${toStr(m33)})`;\n}\n\nconst rotate = (funcName = 'rotate', x = 0.0, y = 0.0, z = 1.0): string => `\nmat4 ${funcName}(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  ${ret(\n    mat4(\n      add(mul('oc', x * x), 'c'),\n      sub(mul('oc', x * y), mul(z, 's')),\n      add(mul('oc', z * x), mul(y, 's')),\n      0,\n      add(mul('oc', x * y), mul(z, 's')),\n      add(mul('oc', y * y), 'c'),\n      sub(mul('oc', y * z), mul(x, 's')),\n      0,\n      sub(mul('oc', z * x), mul(y, 's')),\n      add(mul('oc', y * z), mul(x, 's')),\n      add(mul('oc', z * z), 'c'),\n    ),\n  )}\n}`;\n\nconst rotateZ = (funcName = 'rotateZ'): string => rotate(funcName, 0, 0, 1);\n\nexport const ShaderTool = {\n  add,\n  asFloat,\n  mat4,\n  mul,\n  ret,\n  rotate,\n  rotateZ,\n  sub,\n};\n","import {NearestFilter, TextureFilter, Texture, TextureLoader, LinearFilter, WebGLRenderer} from 'three';\n\nimport {TextureSource} from './types';\n\n/**\n * @category Texture Mapping\n */\nexport interface TextureOptions {\n  magFilter: TextureFilter;\n  minFilter: TextureFilter;\n  anisotrophy: number;\n  flipY: boolean;\n  // TODO encoding @see https://threejs.org/docs/#api/en/constants/Textures\n}\n\nconst TextureClasses = {\n  // TODO encoding classses\n  anisotrophy: {\n    anisotrophy: Infinity,\n  },\n  'anisotrophy-2': {\n    anisotrophy: 2,\n  },\n  'anisotrophy-4': {\n    anisotrophy: 4,\n  },\n  'no-anisotrophy': {\n    anisotrophy: 0,\n  },\n  nearest: {\n    magFilter: NearestFilter,\n    minFilter: NearestFilter,\n  },\n  'mag-nearest': {\n    magFilter: NearestFilter,\n  },\n  'min-nearest': {\n    minFilter: NearestFilter,\n  },\n  linear: {\n    magFilter: LinearFilter,\n    minFilter: LinearFilter,\n  },\n  'mag-linear': {\n    magFilter: LinearFilter,\n  },\n  'min-linear': {\n    minFilter: LinearFilter,\n  },\n  flipy: {\n    flipY: true,\n  },\n  'no-flipy': {\n    flipY: false,\n  },\n};\n\n/**\n * @category Texture Mapping\n */\nexport type TextureOptionClasses = keyof typeof TextureClasses;\n\nconst TextureClassPriority: Record<TextureOptionClasses, number> = {\n  'no-anisotrophy': 1000,\n  'anisotrophy-2': 500,\n  'anisotrophy-4': 250,\n  anisotrophy: 0,\n\n  nearest: 1000,\n  'mag-nearest': 500,\n  'min-nearest': 500,\n\n  linear: 1000,\n  'mag-linear': 500,\n  'min-linear': 500,\n\n  flipy: 10,\n  'no-flipy': 0,\n};\n\n/**\n * @category Texture Mapping\n */\nexport class TextureFactory {\n  #maxAnisotrophy = 0;\n  #defaultOptions: Partial<TextureOptions>;\n\n  textureLoader: TextureLoader;\n\n  constructor(\n    maxAnisotrophyOrRenderer: number | WebGLRenderer = 0,\n    defaultClassNames: Array<TextureOptionClasses> = ['nearest'],\n    defaultOptions?: Partial<TextureOptions>,\n  ) {\n    this.#maxAnisotrophy =\n      typeof maxAnisotrophyOrRenderer === 'number'\n        ? maxAnisotrophyOrRenderer\n        : maxAnisotrophyOrRenderer.capabilities.getMaxAnisotropy();\n    this.#defaultOptions = defaultOptions ?? {\n      anisotrophy: 0,\n      flipY: false,\n    };\n    this.#defaultOptions = this.getOptions(defaultClassNames);\n    this.textureLoader = new TextureLoader();\n  }\n\n  getOptions(classNames: Array<TextureOptionClasses>): Partial<TextureOptions> {\n    const options = Object.assign(\n      {},\n      this.#defaultOptions,\n      ...classNames\n        .map((className) => [TextureClassPriority[className], TextureClasses[className]] as [number, Partial<TextureOptions>])\n        .sort(([a], [b]) => b - a)\n        .map(([, opts]) => opts),\n    );\n    options.anisotrophy = Math.min(options.anisotrophy, this.#maxAnisotrophy);\n    return options;\n  }\n\n  create(source: TextureSource, ...classNames: Array<TextureOptionClasses>): Texture {\n    const texture = new Texture(source);\n    return this.update(texture, ...classNames);\n  }\n\n  update(texture: Texture, ...classNames: Array<TextureOptionClasses>): Texture {\n    Object.assign(texture, this.getOptions(classNames));\n    texture.needsUpdate = true;\n    return texture;\n  }\n\n  load(url: string, ...classNames: Array<TextureOptionClasses>): Texture {\n    return this.textureLoader.load(url, (texture) => {\n      this.update(texture, ...classNames);\n    });\n  }\n}\n","import {Texture} from 'three';\nimport {PowerOf2ImageLoader} from './PowerOf2ImageLoader';\nimport {TextureCoords} from './TextureCoords';\nimport {TextureFactory, TextureOptionClasses} from './TextureFactory';\nimport {TextureSource} from './types';\n\n/**\n * @category Texture Mapping\n */\nexport interface TextureImage {\n  texture: Texture;\n  imgEl: TextureSource;\n  texCoords: TextureCoords;\n}\n\ntype OnLoadCallback = (textureData: TextureImage) => void;\ntype OnErrorCallback = ((event: Event) => void) | undefined;\n\n/**\n * @category Texture Mapping\n */\nexport class TextureImageLoader {\n  imageLoader: PowerOf2ImageLoader;\n  textureFactory: TextureFactory;\n\n  constructor(\n    textureFactory: TextureFactory = new TextureFactory(),\n    imageLoader: PowerOf2ImageLoader = new PowerOf2ImageLoader(),\n  ) {\n    this.textureFactory = textureFactory;\n    this.imageLoader = imageLoader;\n  }\n\n  load(\n    url: string,\n    textureClasses: Array<TextureOptionClasses>,\n    onLoadCallback: OnLoadCallback,\n    onErrorCallback?: OnErrorCallback,\n  ): void {\n    this.imageLoader.load(\n      url,\n      (imageData) => {\n        const texture = new Texture(imageData.imgEl);\n        this.textureFactory.update(texture, ...(textureClasses ?? []));\n\n        onLoadCallback({\n          texture,\n          imgEl: imageData.imgEl,\n          texCoords: imageData.texCoords,\n        });\n      },\n      onErrorCallback,\n    );\n  }\n\n  loadAsync(url: string, textureClasses: Array<TextureOptionClasses>): Promise<TextureImage> {\n    return new Promise((resolve, reject) => {\n      this.load(url, textureClasses, resolve, reject);\n    });\n  }\n}\n","import {TextureAtlas} from './TextureAtlas';\nimport {TextureCoords} from './TextureCoords';\n\n/**\n * @category Texture Mapping\n */\nexport interface TexturePackerFrameData {\n  frame: {\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n  };\n}\n\n/**\n * @category Texture Mapping\n */\nexport interface TexturePackerMetaData {\n  image: string;\n  size: {\n    w: number;\n    h: number;\n  };\n  // TODO add textureOptions: TextureClasses[]\n}\n\n/**\n * @category Texture Mapping\n */\nexport interface TexturePackerJsonData {\n  frames: {\n    [frameName: string]: TexturePackerFrameData;\n  };\n  meta: TexturePackerMetaData;\n}\n\n/**\n * @category Texture Mapping\n */\nexport class TexturePackerJson {\n  static parse(\n    data: TexturePackerJsonData,\n    parentCoords?: TextureCoords,\n    target?: TextureAtlas,\n  ): [atlas: TextureAtlas, meta: TexturePackerMetaData] {\n    target ??= new TextureAtlas();\n\n    parentCoords ??= new TextureCoords(0, 0, data.meta.size.w, data.meta.size.h);\n\n    for (const [name, {frame}] of Object.entries(data.frames)) {\n      target.add(name, new TextureCoords(parentCoords, frame.x, frame.y, frame.w, frame.h));\n    }\n\n    return [target, data.meta];\n  }\n}\n","import {FileLoader} from 'three';\nimport {TextureAtlas} from './TextureAtlas';\nimport {TextureOptionClasses} from './TextureFactory';\nimport {TextureImage, TextureImageLoader} from './TextureImageLoader';\nimport {TexturePackerJson, TexturePackerJsonData, TexturePackerMetaData} from './TexturePackerJson';\n\n/**\n * @category Texture Mapping\n */\nexport interface TextureAtlasData extends TextureImage {\n  atlas: TextureAtlas;\n  meta: TexturePackerMetaData;\n}\n\n/**\n * @category Texture Mapping\n */\nexport interface TextureAtlasLoadOptions {\n  overrideImageUrl?: string;\n}\n\ntype OnLoadCallback = (textureData: TextureAtlasData) => void;\ntype OnErrorCallback = ((event: Event) => void) | undefined;\n\nconst makeFileLoader = () => {\n  const loader = new FileLoader();\n  loader.setResponseType('json');\n  return loader;\n};\n\n/**\n * @category Texture Mapping\n */\nexport class TextureAtlasLoader {\n  fileLoader: FileLoader;\n  textureImageLoader: TextureImageLoader;\n\n  constructor(defaults?: {fileLoader?: FileLoader; textureImageLoader?: TextureImageLoader}) {\n    this.fileLoader = defaults?.fileLoader ?? makeFileLoader();\n    this.textureImageLoader = defaults?.textureImageLoader ?? new TextureImageLoader();\n  }\n\n  load(\n    url: string,\n    textureClasses: Array<TextureOptionClasses> | undefined,\n    options: TextureAtlasLoadOptions | undefined,\n    onLoadCallback: OnLoadCallback,\n    onErrorCallback?: OnErrorCallback,\n  ): void {\n    this.fileLoader.load(\n      url,\n      (jsonData: any) => {\n        const imageUrl = options?.overrideImageUrl ?? (jsonData as TexturePackerJsonData).meta.image;\n\n        this.textureImageLoader.load(\n          imageUrl,\n          textureClasses,\n          ({texture, imgEl, texCoords}) => {\n            const [atlas, meta] = TexturePackerJson.parse(jsonData, texCoords);\n\n            onLoadCallback({atlas, meta, texture, imgEl, texCoords});\n          },\n          onErrorCallback,\n        );\n      },\n      (_xhr) => {\n        // TODO progress callback?\n        // console.log(`${(xhr.loaded / xhr.total) * 100}% loaded`);\n      },\n      onErrorCallback,\n    );\n  }\n\n  loadAsync(\n    url: string,\n    textureClasses?: Array<TextureOptionClasses>,\n    options?: TextureAtlasLoadOptions,\n  ): Promise<TextureAtlasData> {\n    return new Promise((resolve, reject) => {\n      this.load(url, textureClasses, options, resolve, reject);\n    });\n  }\n}\n","import {Texture} from 'three';\nimport {PowerOf2ImageLoader} from './PowerOf2ImageLoader';\nimport {TextureCoords} from './TextureCoords';\nimport {TextureFactory} from './TextureFactory';\nimport {TileSet, TileSetOptions} from './TileSet';\nimport {TextureSource} from './types';\n\n/**\n * @category Texture Mapping\n */\nexport interface TileSetData {\n  tileSet: TileSet;\n  texture: Texture;\n  imgEl: TextureSource;\n  texCoords: TextureCoords;\n}\n\ntype OnLoadCallback = (tileSetData: TileSetData) => void;\ntype OnErrorCallback = ((event: Event) => void) | undefined;\n\n/**\n * @category Texture Mapping\n */\nexport class TileSetLoader {\n  imageLoader: PowerOf2ImageLoader;\n  textureFactory: TextureFactory;\n\n  constructor(\n    textureFactory: TextureFactory = new TextureFactory(),\n    imageLoader: PowerOf2ImageLoader = new PowerOf2ImageLoader(),\n  ) {\n    this.textureFactory = textureFactory;\n    this.imageLoader = imageLoader;\n  }\n\n  load(url: string, tileSetOptions: TileSetOptions, onLoadCallback: OnLoadCallback, onErrorCallback?: OnErrorCallback): void {\n    this.imageLoader.load(\n      url,\n      (imageData) => {\n        const texture = new Texture(imageData.imgEl);\n        texture.name = url;\n\n        this.textureFactory.update(texture);\n\n        const tileSet = new TileSet(imageData.texCoords, tileSetOptions);\n\n        onLoadCallback({\n          texture,\n          tileSet,\n          imgEl: imageData.imgEl,\n          texCoords: imageData.texCoords,\n        });\n      },\n      onErrorCallback,\n    );\n  }\n\n  loadAsync(url: string, tileSetOptions: TileSetOptions): Promise<TileSetData> {\n    return new Promise((resolve, reject) => {\n      this.load(url, tileSetOptions, resolve, reject);\n    });\n  }\n}\n","export const unpick = <T extends Object>(o: T, ...keys: (keyof T)[]): Partial<T> =>\n  o ? (Object.fromEntries(Object.entries(o).filter(([key]) => !keys.includes(key as keyof T))) as Partial<T>) : undefined;\n","import {BufferGeometry} from 'three';\n\nimport {VertexObjectDescriptor} from './VertexObjectDescriptor';\nimport {VertexObjectPool} from './VertexObjectPool';\nimport {initializeAttributes} from './initializeAttributes';\nimport {selectAttributes} from './selectAttributes';\nimport {selectBuffers} from './selectBuffers';\nimport {BufferLike, VertexAttributeUsageType, VertexObjectDescription} from './types';\n\ntype TouchBuffersType = {[Type in VertexAttributeUsageType]?: boolean};\n\n/**\n * @category Vertex Objects\n */\nexport class VertexObjectGeometry extends BufferGeometry {\n  readonly pool: VertexObjectPool;\n  readonly buffers: Map<string, BufferLike> = new Map();\n\n  constructor(source: VertexObjectPool | VertexObjectDescriptor | VertexObjectDescription, capacity: number) {\n    super();\n    this.pool = source instanceof VertexObjectPool ? source : new VertexObjectPool(source, capacity);\n    this.name = 'VertexObjectGeometry';\n    initializeAttributes(this, this.pool, this.buffers);\n  }\n\n  dispose(): void {\n    this.pool.clear();\n    super.dispose();\n  }\n\n  touchAttributes(...attrNames: string[]): void {\n    selectAttributes(this.pool, this.buffers, attrNames).forEach((buffer) => {\n      buffer.needsUpdate = true;\n    });\n  }\n\n  touchBuffers(bufferTypes: TouchBuffersType): void {\n    selectBuffers(this.buffers, bufferTypes).forEach((buffer) => {\n      buffer.needsUpdate = true;\n    });\n  }\n\n  touch(...args: Array<string | TouchBuffersType>): void {\n    const attrNames: string[] = [];\n    let buffers: TouchBuffersType;\n    args.forEach((arg) => {\n      if (typeof arg === 'string') {\n        attrNames.push(arg);\n      } else {\n        buffers = {...buffers, ...arg};\n      }\n    });\n    if (attrNames.length) {\n      this.touchAttributes(...attrNames);\n    }\n    if (buffers) {\n      this.touchBuffers(buffers);\n    }\n  }\n\n  update(): void {\n    this.#autoTouchAttributes();\n    this.#updateDrawRange();\n  }\n\n  #updateDrawRange = (): void => {\n    this.setDrawRange(\n      0,\n      this.pool.descriptor.hasIndices\n        ? this.pool.usedCount * this.pool.descriptor.indices.length\n        : this.pool.usedCount * this.pool.descriptor.vertexCount,\n    );\n  };\n\n  #autoTouchAttributes = (): void => {\n    const autoTouchAttrs = this.#getAutoTouchAttributeNames();\n    if (autoTouchAttrs.length) {\n      this.touchAttributes(...autoTouchAttrs);\n    }\n  };\n\n  #autoTouchAttrNames?: string[];\n\n  #getAutoTouchAttributeNames = (): string[] => {\n    if (!this.#autoTouchAttrNames) {\n      this.#autoTouchAttrNames = Array.from(this.pool.descriptor.attributes.values())\n        .filter((attr) => attr.autoTouch)\n        .map((attr) => attr.name);\n    }\n    return this.#autoTouchAttrNames;\n  };\n}\n","import {Material, Mesh} from 'three';\n\nimport {InstancedVertexObjectGeometry} from './InstancedVertexObjectGeometry';\n\nimport {VertexObjectGeometry} from './VertexObjectGeometry';\n\n/**\n * @category Vertex Objects\n */\nexport interface VertexObjects {\n  geometry: VertexObjectGeometry | InstancedVertexObjectGeometry;\n}\n\n/**\n * @category Vertex Objects\n */\nexport class VertexObjects extends Mesh {\n  constructor(geometry?: VertexObjectGeometry | InstancedVertexObjectGeometry, material?: Material | Material[]) {\n    super(geometry, material);\n    this.name = 'VertexObjects';\n  }\n\n  onBeforeRender = (): void => {\n    this.geometry?.update();\n  };\n}\n"],"names":["voBuffer","Symbol","voIndex","findNextPowerOf2","x","p","__classPrivateFieldGet","receiver","state","kind","f","TypeError","has","call","value","get","__classPrivateFieldSet","set","rand","max","Math","random","TextureAtlas","constructor","_TextureAtlas_frames","this","_TextureAtlas_frameNames","Map","add","args","id","length","isNamedTextureAtlasArgs","push","coords","data","size","frameId","name","frame","frameNames","match","Array","from","keys","regex","RegExp","filter","test","randomFrameId","randomFrame","randomFrameName","randomIdx","idx","randomFrameIds","count","frameIds","i","randomFrames","frames","randomFrameNames","names","minCoord","current","scalarKey","sizeKey","texCoords","scalar","parent","maxCoord","coord","TextureCoords","y","width","height","flip","_a","_b","_c","_d","_e","_f","_g","_h","clone","root","flipH","FLIP_HORIZONTAL","FLIP_VERTICAL","FLIP_DIAGONAL","flipV","flipD","flipHorizontal","flipVertical","flipDiagonal","s","t","s1","t1","u","v","TileSet","tileCount","firstFrameId","_TileSet_createTextureCoords","baseWidth","baseHeight","baseCoords","padding","margin","spacing","tileCountLimit","tileOuterWidth","tileWidth","tileOuterHeight","tileHeight","atlas","Infinity","xOffsetNext","options","firstId","lastId","lastFrameId","tileId","randomTileId","FrameBasedAnimations","_FrameBasedAnimations_animations","_FrameBasedAnimations_names","Error","toString","isArray","sort","map","frameName","tileSet","firstTileId","duration","animId","bakeDataTexture","includeTextureSize","Boolean","bufSize","animationsMap","sizePerTexture","maxTextureSize","anims","values","totalFramesCount","reduce","sum","anim","minBufSize","getBufferSize","MaxTextureSize","floatsBuffer","animations","curOffset","flatMap","offset","renderFloatsBuffer","Float32Array","dataTexture","DataTexture","RGBAFormat","FloatType","needsUpdate","getDescriptorOf","vo","descriptor","createTypedArray","dataType","Float64Array","Uint16Array","Uint32Array","Int32Array","Int16Array","Uint8Array","Uint8ClampedArray","Int8Array","makeAttributeGetter","bufferName","instanceOffset","attrOffset","buffers","typedArray","makeAttributeSetter","makeAttributeValuesGetter","bufferItemSize","vertexCount","attrSize","buf","source","target","subarray","makeAttributeValueSetter","prototype","slice","VertexObjectBuffer","capacityOrBuffersData","buffersData","capacity","attributeNames","bufferAttributes","bufferNameAttributes","buffer","itemSize","usageType","Object","freeze","attributeName","attribute","getAttribute","undefined","bufAttr","voPrototype","basePrototype","props","fromEntries","attrName","attr","AttrName","replace","_match","_m0","m1","toUpperCase","methods","enumerable","hasComponents","components","forEach","component","componentIndex","vertexIndex","create","createVertexObjectPrototype","copy","otherVob","objectOffset","copyWithin","start","end","copyAttributes","attributes","copiedObjCount","entries","attrObjCount","bufIdx","toAttributeArrays","targetArray","targetIdx","bufferIdx","objIdx","VertexAttributeDescriptor","description","type","normalizedData","normalized","usage","autoTouch","VertexObjectDescriptor","bufferNames","Set","attrDesc","meshCount","getInstanceCount","ceil","hasIndices","indices","createVertexObject","objectIndex","writable","VertexObjectPool","capacityOrData","_VertexObjectPool_index","_VertexObjectPool_usedCount","usedCount","setVoIndex","fill","availableCount","clear","createVO","createFromAttributes","firstObjectIdx","objectCount","freeVO","lastUsedIdx","lastUsedVO","getVO","toBuffersData","toDrawUsage","DynamicDrawUsage","StreamDrawUsage","StaticDrawUsage","initializeAttributes","geometry","pool","BufferAttribute","itemCount","arr","stride","j","createIndicesArray","setIndex","interleavedBuffer","InterleavedBuffer","setUsage","InterleavedBufferAttribute","setAttribute","selectAttributes","attrNames","attrs","selectBuffers","bufferTypes","results","drawUsage","InstancedVertexObjectGeometry","InstancedBufferGeometry","super","instancedBuffers","_InstancedVertexObjectGeometry_updateDrawRange","basePool","setDrawRange","_InstancedVertexObjectGeometry_autoTouchAttributes","autoTouchAttrs","touchAttributes","_InstancedVertexObjectGeometry_autoTouchAttrNames","_InstancedVertexObjectGeometry_getAutoTouchAttributeNames","instancedPool","instancedSource","instancedCapacity","BufferGeometry","baseSource","baseCapacity","baseBuffers","meshPerAttribute","InstancedInterleavedBuffer","InstancedBufferAttribute","initializeInstancedAttributes","dispose","touchBuffers","base","instanced","touch","arg","assign","update","instanceCount","isPowerOf2","n","PowerOf2ImageLoader","_PowerOf2ImageLoader_imageLoader","imageLoader","ImageLoader","loader","load","url","onLoadCallback","onErrorCallback","img","imgEl","canvas","document","createElement","getContext","drawImage","imgTexCoords","loadAsync","Promise","resolve","reject","isNumber","a","b","sub","mul","asFloat","number","str","trim","ret","res","mat4","m00","m01","m02","m03","m10","m11","m12","m13","m20","m21","m22","m23","m30","m31","m32","m33","as","toStr","rotate","funcName","z","ShaderTool","rotateZ","TextureClasses","anisotrophy","nearest","magFilter","NearestFilter","minFilter","linear","LinearFilter","flipy","flipY","TextureClassPriority","TextureFactory","maxAnisotrophyOrRenderer","defaultClassNames","defaultOptions","_TextureFactory_maxAnisotrophy","_TextureFactory_defaultOptions","capabilities","getMaxAnisotropy","getOptions","textureLoader","TextureLoader","classNames","className","opts","min","texture","Texture","TextureImageLoader","textureFactory","textureClasses","imageData","TexturePackerJson","parse","parentCoords","meta","w","h","TextureAtlasLoader","defaults","fileLoader","FileLoader","setResponseType","makeFileLoader","textureImageLoader","jsonData","imageUrl","overrideImageUrl","image","_xhr","TileSetLoader","tileSetOptions","unpick","o","key","includes","VertexObjectGeometry","_VertexObjectGeometry_updateDrawRange","_VertexObjectGeometry_autoTouchAttributes","_VertexObjectGeometry_autoTouchAttrNames","_VertexObjectGeometry_getAutoTouchAttributeNames","VertexObjects","Mesh","material","onBeforeRender"],"mappings":"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"}